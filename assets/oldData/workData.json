[
    {
        "name": "Glory Stall",
        "client": "Museum of Sex",
        "client_url": "https://www.superfunland.com/",
        "link": "glory-stall",
        "date": "Dec 2019 - 2021",
        "short": "An erotic take on Wack-A-Mole",
        "info": "The Glory Stall is a hilarious take on the Wack-A-Mole game featured in many carnivals and arcades across the country.  Up to 4 players can compete to see who can pull the most as phallic shaped objects are pushed randomly through a set of 5 holes in each stall.  The player who can 'yank the most planks' wins their choice of a stuffed pepper, eggplant or banana.  Each stall uses a combination of an Arduino Nano and Raspberry Pi to control the various sensors, hardware, and audio playback in each stall.  Each of the 4 Raspberry Pis connect to a single Raspberry Pi using ethernet cables and a desktop switch.  This single Pi awaits user input from the staff to start and stop the game.  The Pis communicate using Open Sound Control.  On each Pi, a Processing IDE sketch is used to control each stall's Pi and the main Pi controlling the game state changes.  The Processing sketch handles audio playback, reading of incoming state changes, scoreboard updating and communication with the Arduino Nano via the Firmata protocol.  The Nano is used to read sensor data to record pulls and control of the relay module to activate pistons and the winner siren light.",
        "tech": [
            [
                "Arduino",
                "https://www.arduino.cc/"
            ],
            [
                "Raspberry Pi",
                "https://www.raspberrypi.org/"
            ],
            [
                "Processing IDE",
                "https://processing.org/"
            ],
            [
                "Fusion 360",
                "https://www.autodesk.com/products/fusion-360/overview"
            ],
            [
                "Open Sound Control",
                "https://opensoundcontrol.stanford.edu/"
            ]
        ],
        "photos": [
            "https://iili.io/63QSC7.jpg",
            "https://iili.io/63QvQS.jpg",
            "https://iili.io/63Qwvf.jpg",
            "https://iili.io/63QUG9.jpg",
            "https://iili.io/63Qg4e.jpg",
            "https://iili.io/63QPvj.jpg",
            "https://iili.io/63Q6Yb.jpg",
            "https://iili.io/63Q43u.jpg"
        ]
    },
    {
        "name": "Lucky Lips",
        "client": "Museum of Sex",
        "client_url": "https://www.superfunland.com/",
        "link": "lucky-lips",
        "date": "Dec 2019 - 2021",
        "short": "A two player kissing game",
        "info": "Lucky Lips uses a GSR sensor to measure the strength of two players' kiss.  The players grab ahold of a metal hand rail mounted on opposite sides of the game and when they kiss or make skin-to-skin contact in another way, the GSR sensor measures the conductance of the two players.  If the players can maintain contact throughout the game, they win a random prize from the wheel mounted in the center.  While most prizes are tongue in cheek suggestions, grand prizes such as free hotel rooms or drink tickets were offered.  An Arduino Uno was used to read sensor data and send it to a Raspberry Pi.  The Pi ran a Processing IDE sketch to control game state changes, color patterns for the multiple sections of LED strips, and handle sensor input from the Arduino Uno using the Firmata protocol.  A Python sketch controlled all audio playback, printing of prize tickets, and emailing staff to alert them when the grand prizes were won. The two sketches communicated locally via the Open Sound Protocol.",
        "tech": [
            [
                "Arduino",
                "https://www.arduino.cc/"
            ],
            [
                "Raspberry Pi",
                "https://www.raspberrypi.org/"
            ],
            [
                "Python",
                "https://www.python.org/"
            ],
            [
                "Processing IDE",
                "https://processing.org/"
            ],
            [
                "Open Sound Control",
                "https://opensoundcontrol.stanford.edu/"
            ],
            [
                "ArtNet",
                "https://art-net.org.uk/"
            ],
            [
                "DMX",
                "https://en.wikipedia.org/wiki/DMX512"
            ]
        ],
        "photos": [
            "https://iili.io/63mVdF.jpg",
            "https://iili.io/63mW5g.jpg",
            "https://iili.io/63mXea.jpg",
            "https://iili.io/63mhmJ.jpg",
            "https://iili.io/63mwzv.jpg",
            "https://iili.io/63mNXR.jpg",
            "https://iili.io/63mOsp.jpg",
            "https://iili.io/63mkqN.jpg"
        ]
    },
    {
        "name": "Vial Dispenser",
        "client": "Museum of Sex",
        "client_url": "https://www.superfunland.com/",
        "link": "vial-dispenser",
        "date": "Jun 2020",
        "short": "An upgrade to an upgrade",
        "info": "The Vial Dispenser was designed and built as a prototype for a new version of the Siren, a game I helped build for the Museum of Sex NYC.  The game involves a metal crank wheel cleverly placed for players to spin.  If the players can keep the wheel spinning for 45 seconds, they win a vial of her essence which is dispensed by the game.  A Raspberry Pi runs a sketch written in Python to control audio playback, game state changes, and serial communication with an Arduino Nano connected via USB.  The Nano runs a script written to receive and send data to the Pi as well as control the motors, sensor input and various lighting elements.  CAD models of the dispenser and parts were designed using Fusion 360 which allowed for parts to be imported directly from McMaster-Carr.  When designs were finalized, parts were 3D printed, ordered from McMaster- Carr or built at my workshop.  Once assembled, testing took place over the course of many days to ensure all mechanism were flawless before both dispensers were shipped to a fabrication shop who would incorporate my design into the final build.",
        "tech": [
            [
                "Arduino",
                "https://www.arduino.cc/"
            ],
            [
                "Raspberry Pi",
                "https://www.raspberrypi.org/"
            ],
            [
                "Python",
                "https://www.python.org/"
            ]
        ],
        "photos": [
            "https://iili.io/63y2us.jpg",
            "https://iili.io/63y3wG.jpg",
            "https://iili.io/63yFtf.jpg",
            "https://iili.io/63yfn4.jpg",
            "https://iili.io/63yqMl.jpg",
            "https://iili.io/63yBP2.jpg",
            "https://iili.io/63ynFS.jpg",
            "https://iili.io/63yoc7.jpg",
            "https://iili.io/63yxS9.jpg",
            "https://iili.io/63yI9e.jpg",
            "https://iili.io/63yTAu.jpg",
            "https://iili.io/63yuwb.jpg",
            "https://iili.io/63yAtj.jpg",
            "https://iili.io/63y5ox.jpg",
            "https://iili.io/63y7MQ.jpg",
            "https://iili.io/63yYPV.jpg",
            "https://iili.io/63ycKB.jpg",
            "https://iili.io/63ylcP.jpg",
            "https://iili.io/63y0S1.jpg",
            "https://iili.io/63yEHF.jpg",
            "https://iili.io/63yGAg.jpg",
            "https://iili.io/63yMNa.jpg",
            "https://iili.io/63yVDJ.jpg"
        ]
    }
]